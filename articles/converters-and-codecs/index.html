<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/Product">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
  <title>Converters and Codecs | Dart: Structured web apps</title>
  <meta property="twitter:account_id" content="376585411" />
  <meta itemprop="name" content="Converters and Codecs | Dart: Structured web apps">
  
  <meta itemprop="image" content="https://www.dartlang.org/imgs/dart-logo-wordmark-1200w.png">
  
  <meta itemprop="description" content="Learn how to write efficient conversions.">



<!-- making pagespeed insights happy -->
<style>
@font-face {
  font-family: 'Montserrat';
  font-style: normal;
  font-weight: 400;
  src: url(https://themes.googleusercontent.com/static/fonts/montserrat/v4/zhcz-_WihjSQC0oHJ9TCYL3hpw3pgy2gAi-Ip7WPMi0.woff) format('woff');
}
@font-face {
  font-family: 'Montserrat';
  font-style: normal;
  font-weight: 700;
  src: url(https://themes.googleusercontent.com/static/fonts/montserrat/v4/IQHow_FEYlDC4Gzy_m8fcnbFhgvWbfSbdVg11QabG8w.woff) format('woff');
}
@font-face {
  font-family: 'Roboto';
  font-style: normal;
  font-weight: 300;
  src: url(https://themes.googleusercontent.com/static/fonts/roboto/v10/Hgo13k-tfSpn0qi1SFdUfbO3LdcAZYWl9Si6vvxL-qU.woff) format('woff');
}
@font-face {
  font-family: 'Roboto';
  font-style: normal;
  font-weight: 400;
  src: url(https://themes.googleusercontent.com/static/fonts/roboto/v10/CrYjSnGjrRCn0pd9VQsnFOvvDin1pK8aKteLpeZ5c0A.woff) format('woff');
}
</style>

<link rel='stylesheet' type='text/css' href='/bundles/96e4b278be2e9b94cffcad9b0b04384c.css' />


  <link rel="author" href="/authors/florian-loitsch.html">
  

  <link rel="alternate" type="application/atom+xml" href="http://news.dartlang.org/feeds/posts/default" title="Atom feed">
  <link href="https://plus.google.com/109866369054280216564" rel="publisher">

  <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!--[if lt IE 9]>
    <script src="js/html5shiv.js"></script>
    <script src="js/respond.min.js"></script>
  <![endif]-->

  <script>

(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-49880327-3', 'dartlang.org');
ga('create', 'UA-26406144-4',
    {'cookieDomain': 'dartlang.org',
     'siteSpeedSampleRate': 50,
     'name': 'dartlangTracker'});

ga('send', 'pageview');
ga('dartlangTracker.send', 'pageview');

</script>


  <script async="" defer="" src="//survey.g.doubleclick.net/async_survey?site=apno2k33xucna4srya26u4i2ri"></script>

</head>
<body onload="prettyPrint()" data-spy="scroll" data-target=".bs-sidebar">

    <div class="navbar navbar-fixed-top navbar-inverse" role="navigation">
      <div class="dart-developer-summit-reg" style="text-align:center;background-color: hsl(172,67%,80%);">
        <a href="/events/2015/summit/">Watch sessions from the first Dart Developer Summit</a>
      </div>
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/"><i class="sprite-icon-dart-logo"></i></a>
        </div>

        <div class="collapse navbar-collapse">
          <ul class="nav navbar-nav">
           <li class="dropdown">
              <a href="#" class="dropdown=toggle" data-toggle="dropdown">
                Get Started <span class="caret"></span>
              </a>
              <ul class="dropdown-menu">

                <i class="sprite-icon-dd-tip"></i>
                <li><a href="/codelabs/darrrt/">Learn Dart in Minutes</a></li>
                <li><a href="/downloads/">Download Dart</a></li>
              </ul>
            </li>

            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">
                    Fundamentals <span class="caret"></span>
              </a>
              <ul class="dropdown-menu">
                <i class="sprite-icon-dd-tip"></i>
                <li><a href="/docs/dart-up-and-running/ch02.html">Language Tour</a></li>
                <li><a href="/docs/dart-up-and-running/ch03.html">Library Tour</a></li>
                <li><a href="/docs/">Programmer's Guide</a></li>

                <li class="divider"></li>
                <li><a href="/tools/">Dart Tools</a></li>
                <li><a href="/tools/pub/">Pub Package and Asset Manager</a></li>

                <li class="divider"></li>
                <li><a href="/docs/tutorials/get-started/">Tutorial: Get Started</a></li>
                <li><a href="/docs/tutorials/shared-pkgs/">Tutorial: Packages</a></li>
                <li><a href="/docs/tutorials/futures/">Tutorial: Async</a></li>
              </ul>
            </li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">
                    Browser<span class="caret"></span>
              </a>
              <ul class="dropdown-menu">
                <i class="sprite-icon-dd-tip"></i>
                <li><a href="/polymer/">Polymer</a></li>
                <li><a href="/codelabs/polymer/">Polymer Code Lab</a></li>
                <li class="divider"></li>
                <i class="sprite-icon-dd-tip"></i>
                <li><a href="/docs/tutorials/connect-dart-html/">Tutorial: HTML</a></li>
                <li><a href="/docs/tutorials/polymer-intro/">Tutorial: Polymer</a></li>
                <li><a href="/docs/tutorials/fetchdata/">Tutorial: Forms & Data</a></li>
                <li class="divider"></li>
                <i class="sprite-icon-dd-tip"></i>
                <li><a href="/tools/editor/mobile.html">Mobile</a></li>

                <li class="divider"></li>
                <i class="sprite-icon-dd-tip"></i>
                <li><a href="/googleapis/">Google APIs Client Libraries</a></li>
              </ul>
            </li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">
                    Server <span class="caret"></span>
              </a>
              <ul class="dropdown-menu">
                <i class="sprite-icon-dd-tip"></i>
                <li><a href="/docs/tutorials/cmdline/">Tutorial: Basic Command-Line Apps</a></li>
                <li><a href="/docs/tutorials/httpserver/">Tutorial: HTTP Servers and Clients</a></li>

                <li class="divider"></li>
                <li><a href="/server/google-cloud-platform/">Deploying Your Server Application</a></li>
                <i class="sprite-icon-dd-tip"></i>
                <li><a href="/googleapis/">Using Google APIs from Your Server</a></li>

                <li class="divider"></li>
                <li><a href="/docs/serverguide.html">Additional Resources</a></li>
              </ul>
            </li>

            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">
                    More <span class="caret"></span>
              </a>
              <ul class="dropdown-menu">
                <i class="sprite-icon-dd-tip"></i>

                <li><a href="/samples/">Code Samples</a></li>
                <li><a href="/docs/synonyms/">Synonyms with Other Languages</a></li>
                <li><a href="/dart-by-example/">Dart by Example</a></li>

                <li class="divider"></li>
                <li><a href="/articles/">Articles</a></li>
                <li><a href="http://api.dartlang.org">API Reference</a></li>
                <li><a href="/docs/spec/">Language Specification</a></li>

                <li class="divider"></li>
                <li><a href="/community/who-uses-dart.html">Who Uses Dart</a></li>
                <li><a href="/support/faq.html">FAQ</a></li>
                <li><a href="/logos/">Logos and Colors</a></li>
                <li><a href="/books/">Books</a></li>
                <li><a href="/performance/">Performance</a></li>

                <li class="divider"></li>
                <li><a href="/slides/">Presentations</a></li>
                <li><a href="/dart-tips/">Dart Tips Videos</a></li>
                <li><a href="/support/">Support</a></li>
              </ul>
            </li>
          </ul>

          <ul class="nav navbar-nav navbar-right">
            <li>
              <form class="navbar-search" action="/search.html" id="cse-search-box">
                <input type="hidden" name="cx" value="011220921317074318178:i4mscbaxtru">
                <input type="hidden" name="ie" value="UTF-8">
                <input type="hidden" name="hl" value="en">
                <input type="search" name="q" class="search-query placeholder-position-fix form-control" id="q" autocomplete="off" placeholder="Search">
              </form>
            </li>
            <li><a href="https://twitter.com/dart_lang" class="btn"><i class="sprite-icon-social-twitter"></i></a></li>
            <li><a href="https://plus.google.com/+dartlang/posts" class="btn"><i class="sprite-icon-social-gplus"></i></a></li>
          </ul>
        </div><!-- /.nav-collapse -->

      </div><!-- /.container -->
    </div><!-- /.navbar -->


<div class="container-page">
  <div class="container">
  	<div class="container sub-page">
      <div class="row">
        <article class="has-permalinks"><div class="col-md-4">
  <div class="bs-sidebar" data-spy="affix" data-offset-bottom="350" role="complementary">

<ol class="toc nav bs-sidenav" id="markdown-toc">
  <li><a href="#big-picture">Big picture</a></li>
  <li><a href="#codec">Codec</a></li>
  <li><a href="#converter">Converter</a></li>
  <li><a href="#chunked-conversion">Chunked conversion</a>    <ol>
      <li><a href="#chunkedconversionsink">ChunkedConversionSink</a></li>
    </ol>
  </li>
  <li><a href="#example">Example</a>    <ol>
      <li><a href="#specialized-chunkedconversionsinks">Specialized ChunkedConversionSinks</a></li>
    </ol>
  </li>
</ol>

  </div>
</div>
<div class="col-md-8">
  <p><!-- Start of content -->
</p>

  <div>
    <ol class="breadcrumb">

  <li><a href="/articles/">
  Articles</a></li>


  <li class="active">Converters and Codecs</li>
</ol>
  </div>

  <h1 id="converters-and-codecs">Converters and Codecs</h1>
  <p class="subtitle"><strong><em>How to write efficient conversions</em></strong></p>

  <p><em>Written by Florian Loitsch <br />
<time pubdate="" date="2014-02-06">February 2014</time>
(updated March 2015)
</em></p>

  <p>Converting data between different representations is a common task in computer
engineering. Dart is no exception and comes with
<a href="https://api.dartlang.org/dart_convert.html">dart:convert</a>, a
core library that provides a set of converters
and useful tools to build new converters.
Examples of converters provided by the library include those
for commonly used encodings such as JSON and UTF-8.
In this document, we show how Dart‚Äôs
converters work and how you can create your own efficient converters
that fit into the Dart world.</p>

  <h2 id="big-picture">Big picture</h2>

  <p>Dart‚Äôs conversion architecture is
based on <em>converters</em>, which translate from one representation to another.
When conversions are reversible, two converters are grouped together into a
<em>codec</em> (coder-decoder). The term codec is frequently used for audio and
video processing but also applies to string encodings such as UTF-8 or JSON.</p>

  <p>By convention, all converters in Dart use the abstractions provided in the
dart:convert library. This provides a consistent API for developers and ensures
that converters can work together.
For instance, converters (or codecs) can be fused together if their
type matches, and the resulting converter can then be used as a single unit.
Furthermore, these fused converters frequently work more efficiently than if
they had been used separately.</p>

  <h2 id="codec">Codec</h2>

  <p>A codec is a combination of two converters where one encodes
and the other one decodes:</p>

  <pre class="prettyprint lang-dart">
abstract class Codec&lt;S, T&gt; {
  const Codec();

  T encode(S input) =&gt; encoder.convert(input);
  S decode(T encoded) =&gt; decoder.convert(encoded);

  Converter&lt;S, T&gt; get encoder;
  Converter&lt;T, S&gt; get decoder;

  Codec&lt;S, dynamic&gt; fuse(Codec&lt;T, dynamic&gt; other) { .. }
  Codec&lt;T, S&gt; get inverted =&gt; ...;
}
</pre>

  <p>As can be seen, codecs provide convenience methods such as <code>encode()</code> and
<code>decode()</code> that are expressed in terms of the encoder and decoder. The <code>fuse()</code>
method and <code>inverted</code> getter allow you to fuse converters and
change the direction of a codec, respectively.
The base implementation of
<a href="https://api.dartlang.org/dart_convert/Codec.html">Codec</a> 
for these two members
provides a solid default implementation
and implementers usually don‚Äôt need to worry about them.</p>

  <p>The <code>encode()</code> and <code>decode()</code>
methods, too, may be left untouched, but they can be extended for additional
arguments. For example, the
<a href="https://api.dartlang.org/dart_convert/JsonCodec.html">JsonCodec</a>
adds named arguments to <code>encode()</code> and <code>decode()</code>
to make these methods more useful:</p>

  <pre class="prettyprint lang-dart">
dynamic decode(String source, {reviver(var key, var value)}) { ‚Ä¶ }
String encode(Object value, {toEncodable(var object)}) { ‚Ä¶ }
</pre>

  <p>The codec can be instantiated with arguments that are used as default
values, unless they are overridden by the named arguments during the
<code>encode()</code>/<code>decode()</code> call.</p>

  <pre class="prettyprint lang-dart">
const JsonCodec({reviver(var key, var value), toEncodable(var object)})
  ...
</pre>

  <p>As a general rule: if a codec can be configured, it should add named arguments
to the <code>encode()</code>/<code>decode()</code> methods and allow their defaults to be
set in constructors.
When possible, codec constructors should be <code>const</code> constructors.</p>

  <h2 id="converter">Converter</h2>

  <p>Converters, and in particular their <code>convert()</code> methods, are
where the real conversions happen:</p>

  <pre class="prettyprint lang-dart">
T convert(S input);  // where T is the target and S the source type.
</pre>

  <p>A minimal converter implementation only needs to extend the
<a href="https://api.dartlang.org/dart_convert/Converter.html">Converter</a> class and
implement the <code>convert()</code> method. Similar to the Codec class, converters can be
made configurable by extending the constructors and adding named arguments to
the <code>convert()</code> method.</p>

  <p>Such a minimal converter works in synchronous settings, but
does not work when used with chunks (either synchronously or asynchronously). In
particular, such a simple converter doesn‚Äôt work as a transformer (one of the
nicer features of Converters). A fully implemented converter implements the
<a href="https://api.dartlang.org/dart_async/StreamTransformer.html">StreamTransformer</a>
interface and can thus be given to the <code>Stream.transform()</code> method.</p>

  <p>Probably the most common use case is the decoding of UTF-8 with
<a href="https://api.dartlang.org/dart_convert.html#UTF8">UTF8.decoder</a>:</p>

  <pre class="prettyprint lang-dart">
File.openRead().transform(UTF8.decoder).
</pre>

  <h2 id="chunked-conversion">Chunked conversion</h2>

  <p>The concept of chunked conversions can be confusing, but at its core, it is
relatively simple. When a chunked conversion (including a stream transformation)
is started, the converter‚Äôs
<a href="https://api.dartlang.org/dart_convert/Converter.html#startChunkedConversion">startChunkedConversion</a>
method is invoked with an output-
sink as argument. The method then returns an input sink into which the caller
puts data.</p>

  <p><img src="images/chunked-conversion.png" alt="Chunked converstion" /></p>

  <p><strong>Note</strong>: An asterisk (<code>*</code>) in the diagram represents optional multiple calls.</p>

  <p>In the diagram, the first step consists of creating an <code>outputSink</code> that should
be filled with the converted data. Then, the user invokes the
<code>startChunkedConversion()</code> method of the converter with the output sink.
The result is an input sink with methods <code>add()</code> and <code>close()</code>.</p>

  <p>At a later point, the code that started the chunked conversion invokes,
possibly multiple times, the <code>add()</code> method with
some data. The data is converted by the input sink. If the converted data is
ready the input sink sends it to the output sink, possibly with multiple
<code>add()</code> calls. Eventually the user finishes the conversion by invoking
<code>close()</code>. At this point any remaining converted data is sent from the input
sink to the output sink and the output sink is closed.</p>

  <p>Depending on the converter the input sink may need to buffer parts of the
incoming data. For example, a line-splitter that receives <code>ab\ncd</code> as the first
chunk can safely invoke its output sink with <code>ab</code>, but needs to wait for the
next data (or the <code>close()</code> call) before it can handle <code>cd</code>. If the next data is
<code>e\nf</code>, the input sink must concatenate <code>cd</code> and <code>e</code> and invoke the output sink
with the string <code>cde</code>, while buffering <code>f</code> for the next data event (or the
<code>close()</code> call).</p>

  <p>The complexity of the input sink (in combination with the converter) varies.
Some chunked conversions are trivially mapped to the non-chunked versions (like
a String‚ÜíString converter that removes the character <code>a</code>), while others are
more complicated. A safe, although inefficient (and usually unrecommended)
way to implement the chunked conversion is to buffer and concatenate all the
incoming data and to do the conversion in one go. This is, how the JSON decoder
is currently (January 2014) implemented.</p>

  <p>Interestingly, the type of chunked conversion cannot be extrapolated from its
synchronous conversion. For example, the
<a href="https://api.dartlang.org/dart_convert/HtmlEscape.html">HtmlEscape</a>
converter synchronously
converts Strings to Strings, and asynchronously converts chunks of Strings to
chunks of Strings (String‚ÜíString). The
<a href="https://api.dartlang.org/dart_convert/LineSplitter.html">LineSplitter</a>
converter synchronously
converts Strings to List<string> (the individual lines). Despite the difference
in the synchronous signature, the chunked version of the LineSplitter converter
has the same signature as
HtmlEscape: String‚ÜíString. In this case each individual output chunk
represents one line.</string></p>

  <pre class="prettyprint lang-dart">
import &#39;dart:convert&#39;;
import &#39;dart:async&#39;;

main() async {
  // HtmlEscape synchronously converts Strings to Strings.
  print(const HtmlEscape().convert(&quot;foo&quot;)); // &quot;foo&quot;.
  // When used in a chunked way it converts from Strings
  // to Strings.
  var stream = new Stream.fromIterable([&quot;f&quot;, &quot;o&quot;, &quot;o&quot;]);
  print(await (stream.transform(const HtmlEscape())
                     .toList()));    // [&quot;f&quot;, &quot;o&quot;, &quot;o&quot;].

  // LineSplitter synchronously converts Strings to Lists of String.
  print(const LineSplitter().convert(&quot;foo\nbar&quot;)); // [&quot;foo&quot;, &quot;bar&quot;]
  // However, asynchronously it converts from Strings to Strings (and
  // not Lists of Strings).
  var stream2 = new Stream.fromIterable([&quot;fo&quot;, &quot;o\nb&quot;, &quot;ar&quot;]);
  print(&quot;${await (stream2.transform(const LineSplitter())
                          .toList())}&quot;);
}
</pre>

  <p>In general, the type of the chunked conversion is determined by the most
useful case when used as a StreamTransformer.</p>

  <h3 id="chunkedconversionsink">ChunkedConversionSink</h3>

  <p><a href="https://api.dartlang.org/dart_convert/ChunkedConversionSink.html">ChunkedConversionSinks</a>
are used to add new data to a
converter or as output from converters. The basic ChunkedConversionSink comes
with two methods: <code>add()</code> and <code>close()</code>. These have the same functionality as in
all other sinks of the system such as
<a href="https://api.dartlang.org/dart_core/StringSink.html">StringSinks</a>
or
<a href="https://api.dartlang.org/dart_async/StreamSink.html">StreamSinks</a>.</p>

  <p>The ChunkedConversionSinks semantics are similar to that of
<a href="https://api.dartlang.org/dart_io/IOSink.html">IOSinks</a>:
data added to the
sink must not be modified unless it can be guaranteed that the data has been
handled. For Strings this is not a problem (since they are immutable), but for
lists of bytes it frequently means allocating a fresh copy of the list. This
can be inefficient and the dart:convert library thus comes with subclasses of
ChunkedConversionSink that support more efficient ways of passing data.</p>

  <p>For instance, the
<a href="https://api.dartlang.org/dart_convert/ByteConversionSink.html">ByteConversionSink</a>,
has the additional method</p>

  <p><code>addSlice(List&lt;int&gt; chunk, int start, int end, bool isLast)</code></p>

  <p>Semantically, it
accepts a list (which may not be held onto), the sub-range that the converter
operates on, and a boolean <code>isLast</code>, which can be set instead of calling
<code>close()</code>.</p>

  <pre class="prettyprint lang-dart">
import &#39;dart:convert&#39;;

main() {
  var outSink = new ChunkedConversionSink.withCallback((chunks) {
    print(chunks.single); // ùÖ°
  });

  var inSink = UTF8.decoder.startChunkedConversion(outSink);
  var list = [0xF0, 0x9D];
  inSink.addSlice(list, 0, 2, false);
  // Since we used `addSlice` we are allowed to reuse the list.
  list[0] = 0x85;
  list[1] = 0xA1;
  inSink.addSlice(list, 0, 2, true);
}
</pre>

  <p>As a user of the chunked conversion sink (which is used both as input and output
of converters), this simply provides more choice. The fact that the list is not
held onto, means that you can use a cache and reuse that one for every call.
Combining <code>add()</code> with <code>close()</code> may help the receiver in that it can avoid
buffering data. Accepting sub-lists avoids expensive calls to <code>subList()</code>
(to copy the data).</p>

  <p>The drawback of this interface is that it is more complicated to implement. To
ease the pain for developers, every improved chunked conversion sink of
dart:convert also comes with a base class that implements all methods except one
(which is abstract). The implementor of the conversion sink can then decide
whether to take advantage of the additional methods.</p>

  <p><strong>Note</strong>: <em>Chunked conversion sinks *must* extend the corresponding base class.
This assures that adding functionality to the existing sink interfaces does
not break the extended sinks.</em></p>

  <h2 id="example">Example</h2>

  <p>This section shows all the steps needed to create a simple encryption
converter and how a custom ChunkedConversionSink can improve performance.</p>

  <p>Let‚Äôs start with the simple synchronous converter,
whose encryption routine simply rotates bytes by the given key:</p>

  <pre class="prettyprint lang-dart">
import &#39;dart:convert&#39;;

/// A simple extension of Rot13 to bytes and a key.
class RotConverter extends Converter&lt;List&lt;int&gt;, List&lt;int&gt;&gt; {
  final _key;
  const RotConverter(this._key);

  List&lt;int&gt; convert(List&lt;int&gt; data, { int key }) {
    if (key == null) key = this._key;
    var result = new List&lt;int&gt;(data.length);
    for (int i = 0; i &lt; data.length; i++) {
      result[i] = (data[i] + key) % 256;
    }
    return result;
  }
}
</pre>

  <p>The corresponding Codec class is also simple:</p>

  <pre class="prettyprint lang-dart">
class Rot extends Codec&lt;List&lt;int&gt;, List&lt;int&gt;&gt; {
  final _key;
  const Rot(this._key);

  List&lt;int&gt; encode(List&lt;int&gt; data, { int key }) {
    if (key == null) key = this._key;
    return new RotConverter(key).convert(data);
  }

  List&lt;int&gt; decode(List&lt;int&gt; data, { int key }) {
    if (key == null) key = this._key;
    return new RotConverter(-key).convert(data);
  }

  RotConverter get encoder =&gt; new RotConverter(_key);
  RotConverter get decoder =&gt; new RotConverter(-_key);
}
</pre>

  <p>We can (and should) avoid some of the <code>new</code> allocations, but for simplicity we
allocate a new instance of RotConverter every time one is needed.</p>

  <p>This is how we use the Rot codec:</p>

  <pre class="prettyprint lang-dart">
const Rot ROT128 = const Rot(128);
const Rot ROT1 = const Rot(1);
main() {

  print(const RotConverter(128).convert([0, 128, 255, 1]));   // [128, 0, 127, 129]
  print(const RotConverter(128).convert([128, 0, 127, 129])); // [0, 128, 255, 1]
  print(const RotConverter(-128).convert([128, 0, 127, 129]));// [0, 128, 255, 1]

  print(ROT1.decode(ROT1.encode([0, 128, 255, 1])));          // [0, 128, 255, 1]
  print(ROT128.decode(ROT128.encode([0, 128, 255, 1])));      // [0, 128, 255, 1]
}
</pre>

  <p>We are on the right track. The codec works, but it is still missing the chunked
encoding part. Because each byte is encoded separately we can fall back to
the synchronous conversion method:</p>

  <pre class="prettyprint lang-dart">
class RotConverter {
  ...
  RotSink startChunkedConversion(sink) {
    return new RotSink(_key, sink);
  }
}
 
class RotSink extends ChunkedConversionSink&lt;List&lt;int&gt;&gt; {
  final _converter;
  final ChunkedConversionSink&lt;List&lt;int&gt;&gt; _outSink;
  RotSink(key, this._outSink) : _converter = new RotConverter(key);

  void add(List&lt;int&gt; data) {
    _outSink.add(_converter.convert(data));
  }

  void close() {
    _outSink.close();
  }
}

</pre>

  <p>Now, we can use the converter with chunked conversions or even for stream 
transformations:</p>

  <pre class="prettyprint lang-dart">
// Requires to import dart:io.
main(args) {
  String inFile = args[0];
  String outFile = args[1];
  int key = int.parse(args[2]);
  new File(inFile)
    .openRead()
    .transform(new RotConverter(key))
    .pipe(new File(outFile).openWrite());
}
</pre>

  <h3 id="specialized-chunkedconversionsinks">Specialized ChunkedConversionSinks</h3>

  <p>For many purposes, the current version of Rot is sufficient. That is, the
benefit of improvements would be outweighed by the cost of more complex code
and test requirements. Let‚Äôs assume, however,
that the performance of the converter is critical
(it‚Äôs on the hot path and up on the profile).
We furthermore assume that
the cost of allocating a new list for every chunk is killing performance
(a reasonable assumption).</p>

  <p>We start by making the allocation cost cheaper: by using a
<a href="https://api.dartlang.org/docs/channels/stable/latest/dart_typed_data/Uint8List.html">typed byte-list</a>
we can reduce the size of the allocated list by a factor of 8 (on 64-bit
machines). This one line change doesn‚Äôt remove the allocation, but makes it much
cheaper.</p>

  <p>We can also avoid the allocation altogether if we overwrite the input. In
the following version of RotSink, we add a new method <code>addModifiable()</code> that
does exactly that:</p>

  <pre class="prettyprint lang-dart">
class RotSink extends ChunkedConversionSink&lt;List&lt;int&gt;&gt; {
  final _key;
  final ChunkedConversionSink&lt;List&lt;int&gt;&gt; _outSink;
  RotSink(this._key, this._outSink);

  void add(List&lt;int&gt; data) {
    addModifiable(new Uint8List.fromList(data));
  }

  void addModifiable(List&lt;int&gt; data) {
    for (int i = 0; i &lt; data.length; i++) {
      data[i] = (data[i] + _key) % 256;
    }
    _outSink.add(data);
  }

  void close() {
    _outSink.close();
  }
}
</pre>

  <p>For simplicity we propose a new method that consumes a complete list. A more
advanced method (for example <code>addModifiableSlice()</code>) would take range arguments
(<code>from</code>, <code>to</code>) and an <code>isLast</code> boolean as arguments.</p>

  <p>This new method is not yet used by transformers, but we can already use it when
invoking <code>startChunkedConversion</code> explicitly.</p>

  <pre class="prettyprint lang-dart">

main() {
  var outSink = new ChunkedConversionSink.withCallback((chunks) {
    print(chunks); // [[31, 32, 33], [24, 25, 26]]
  });
  var inSink = new RotConverter(30).startChunkedConversion(outSink);
  inSink.addModifiable([1, 2, 3]);
  inSink.addModifiable([250, 251, 252]);
  inSink.close();
}
</pre>

  <p>In this small example, performance isn‚Äôt visibly different,
but internally the
chunked conversion avoids allocating new lists for the individual chunks.
For two small chunks, it doesn‚Äôt make a difference, but
if we implement this for the stream transformer,
encrypting a bigger file can be noticeably faster.</p>

  <p>To do this,
we can make use of the undocumented feature that IOStreams provide modifiable lists.
We could now simply rewrite <code>add()</code> and
point it directly to <code>addModifiable()</code>. In general, this is not safe,
and
such a converter would be the potential source of hard-to-track bugs. Instead,
we write a converter that does the unmodifiable-to-modifiable conversion
explicitly, and then fuse the two converters.</p>

  <pre class="prettyprint lang-dart">
class ToModifiableConverter extends Converter&lt;List&lt;int&gt;, List&lt;int&gt;&gt; {
  List&lt;int&gt; convert(List&lt;int&gt; data) =&gt; data;
  ToModifiableSink startChunkedConversion(RotSink sink) {
    return new ToModifiableSink(sink);
  }
}

class ToModifiableSink
    extends ChunkedConversionSink&lt;List&lt;int&gt;, List&lt;int&gt;&gt; {
  final RotSink sink;
  ToModifiableSink(this.sink);

  void add(List&lt;int&gt; data) { sink.addModifiable(data); }
  void close() { sink.close(); }
}
</pre>

  <p>ToModifiableSink just signals the next sink that the incoming chunk
is modifiable. We can use this to make our pipeline more efficient:</p>

  <pre class="prettyprint lang-dart">
main(args) {
  String inFile = args[0];
  String outFile = args[1];
  int key = int.parse(args[2]);
  new File(inFile)
      .openRead()
      .transform(
          new ToModifiableConverter().fuse(new RotConverter(key)))
      .pipe(new File(outFile).openWrite());
}
</pre>

  <p>On my machine, this small modification brought the encryption time of an 11MB
file from 450ms down to 260ms. We achieved this speed up without losing
compatibility with existing codecs (with regard to the <code>fuse()</code> method)
and the converter still functions as a stream transformer.</p>

  <p>Reusing the input works nicely with other
converters and not just with our Rot cipher. We should therefore make an
interface that generalizes the concept. For simplicity, we named it
<code>CipherSink</code>, although it has, of course, uses outside the encryption world.</p>

  <pre class="prettyprint lang-dart">
abstract class CipherSink
    extends ChunkedConversionSink&lt;List&lt;int&gt;, List&lt;int&gt;&gt; {
  void addModifiable(List&lt;int&gt; data) { add(data); }
}
</pre>

  <p>We can then make our RotSink private and expose the CipherSink instead.
Other developers can now reuse our work (CipherSink and ToModifiableConverter)
and benefit from it.</p>

  <p>But we are not done yet.</p>

  <p>Although we won‚Äôt make the cipher faster anymore,
we can improve the output side of our Rot converter.
Take, for instance, the fusion of two encryptions:</p>

  <pre class="prettyprint lang-dart">
main(args) {
  String inFile = args[0];
  String outFile = args[1];
  int key = int.parse(args[2]);
  // Double-strength cipher running the Rot-cipher twice.
  var transformer = new ToModifiableConverter()
       .fuse(new RotConverter(key))  // &lt;= fused RotConverters.
       .fuse(new RotConverter(key));
  new File(inFile)
      .openRead()
      .transform(transformer)
      .pipe(new File(outFile).openWrite());
}
</pre>

  <p>Since the first RotConverter invokes <code>outSink.add()</code>, the second RotConverter
assumes that input cannot be modified and allocates a copy. We can work around
this by sandwiching a ToModifiableConverter in between the two ciphers:</p>

  <pre class="prettyprint lang-dart">
  var transformer = new ToModifiableConverter()
       .fuse(new RotConverter(key))
       .fuse(new ToModifiableConverter())
       .fuse(new RotConverter(key));
</pre>

  <p>This works, but is hackish. We want the RotConverters to work without
intermediate converters. The first cipher should look at the outSink and
determines if it is a CipherSink or not. We can do this either,
whenever we want to add a new chunk,
or at the beginning when we start a chunked
conversion. We prefer the latter approach:</p>

  <pre class="prettyprint lang-dart">
  /// Works more efficiently if given a CipherSink as argument.
  CipherSink startChunkedConversion(
      ChunkedConversionSink&lt;List&lt;int&gt;&gt; sink) {
    if (sink is! CipherSink) sink = new _CipherSinkAdapter(sink);
    return new _RotSink(_key, sink);
  }
</pre>

  <p>_CipherSinkAdapter is simply:</p>

  <pre class="prettyprint lang-dart">
class _CipherSinkAdapter implements CipherSink {
  ChunkedConversionSink&lt;List&lt;int&gt;, List&lt;int&gt;&gt; sink;
  _CipherSinkAdapter(this.sink);

  void add(data) { sink.add(data); }
  void addModifiable(data) { sink.add(data); }
  void close() { sink.close(); }
}
</pre>

  <p>We now only need to change the _RotSink to take advantage of the fact that it
always receives a CipherSink as an argument to its constructor:</p>

  <pre class="prettyprint lang-dart">
class _RotSink extends CipherSink {
  final _key;
  final CipherSink _outSink;  // &lt;= always a CipherSink.
  _RotSink(this._key, this._outSink);

  void add(List&lt;int&gt; data) {
    addModifiable(data.toList());
  }

  void addModifiable(List&lt;int&gt; data) {
    for (int i = 0; i &lt; data.length; i++) {
      data[i] = (data[i] + _key) % 256;
    }
    _outSink.addModifiable(data);  // &lt;= safe to call addModifiable.
  }

  void close() {
    _outSink.close();
  }
}
</pre>

  <p>With these changes our super secure, double cipher won‚Äôt allocate any new lists
and our work is done.</p>

  <p>Thanks to Lasse Reichstein Holst Nielsen, Anders Johnsen, and Matias Meno who
were a great help in writing this article.</p>
</div>

    	  </div> <!-- End of content from toc.html -->
        </article>
	  </div>

	
	<ul class="pager hidden-print">
	  <li><a href="/articles/">More articles about Dart <i class="glyphicon glyphicon-chevron-up"></i></a></li>
	 </ul>
	 

	</div>
  </div>
</div>


  <footer class="footer container-full hidden-print">
    <div class="container">
      <div class="row">
        <div class="col-md-5">
          <h3>A new language, with tools and libraries, for SCALABLE web app engineering</h3>
          <p>Dart is an <a href="https://code.google.com/p/dart/">open-source project</a> with contributors from Google and elsewhere.</p>
          <p class="sm">Except as otherwise noted, the content of this page is licensed under the Creative Commons Attribution 3.0 License, and code samples are licensed under the BSD License.</p>
        </div>
        <div class="col-md-2 col-md-offset-1">
          <h4>Popular Topics</h4>
          <ul>
            <li><a href="/polymer/?utm_source=site&amp;utm_medium=footer&amp;utm_campaign=homepage">Polymer.dart</a></li>
            <li><a href="/performance/">Performance</a></li>
            <li><a href="/docs/dart-up-and-running/ch02.html?utm_source=site&amp;utm_medium=footer&amp;utm_campaign=homepage">Language tour</a> &amp;
            <a href="/docs/dart-up-and-running/ch03.html?utm_source=site&amp;utm_medium=footer&amp;utm_campaign=homepage">library tour</a></li>
            <li><a href="/samples/?utm_source=site&amp;utm_medium=footer&amp;utm_campaign=homepage">Code samples</a></li>
            <li><a href="/docs/tutorials/?utm_source=site&amp;utm_medium=footer&amp;utm_campaign=homepage">Tutorials</a> &amp;
                <a href="/codelabs/darrrt/?utm_source=site&amp;utm_medium=footer&amp;utm_campaign=homepage">code lab</a></li>
          </ul>
        </div>
        <div class="col-md-2">
          <h4>Resources</h4>
          <ul>
            <li><a href="http://pub.dartlang.org/">Pub packages</a></li>
            <li><a href="/docs/synonyms/">Synonyms with other languages</a></li>
            <li><a href="http://code.google.com/p/dart/issues/list">Dart bugs and feature requests</a></li>
            <li><a href="https://github.com/dart-lang/dartlang.org">www.dartlang.org repo</a></li>
          </ul>
        </div>
        <div class="col-md-2">
          <h4>Community</h4>
          <ul>
            <li><a href="/support/">Mailing lists</a></li>
            <li><a href="https://plus.google.com/communities/114566943291919232850">G+ community</a></li>
            <li><a href="https://plus.google.com/+dartlang/posts">G+ announcement group</a></li>
            <li><a href="http://stackoverflow.com/questions/tagged/dart">Stack Overflow</a></li>
          </ul>
        </div>
      </div>
    </div>
  </footer> <!-- End footer -->



<script type='text/javascript' src='/bundles/d0739a444baf6bcd9d6405389c2e294f.js'></script>




<link rel='stylesheet' type='text/css' href='/bundles/2afe6beaa026f8648e912263a89be985.css' />


<link href="/articles/converters-and-codecs/styles.css" rel="stylesheet" type="text/css">



</body>
</html>

